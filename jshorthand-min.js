module.exports=function e(n,t=n){if(!(n instanceof Object))throw new TypeError("Primitive types cannot be wrapped.");if(n.$_isWrapper)return n;const r={get:function(e,n){if("toString"==n||"valueOf"==n)return()=>s.val[n]();{return void 0!==e.$_ref[n]?t(e.$_ref[n]):void 0!==s.val[n]?s.val[n]:t(e[n]);function t(n){return n instanceof Function&&n!==e.$_val&&n!==e.$_pass?(s.setFn(n),a):n}}},set:()=>{throw new Error("Forbidden. Use set() to set inner object fields.")}},i=function(...e){return s.reapply(e),a},s={val:n,args:[],fn:n instanceof Function?n:i.$_pass,publicNames:["pass","ref","val","do","set"],save:function(e,n,t=this.val){this.fn=e,this.args=n,this.val=t},setFn:function(e){this.fn=e,this.args=[]},reapply:function(e){0===e.length&&(e=this.args),this.save(this.fn,e,this.fn.apply(t,e))}},a=new Proxy(i,r);i.$_ref=n,i.$_isWrapper=!0,i.$_pass=function(n=s.val){if(null==n)throw new TypeError("Cannot pass to an undefined return value.");return n==i.$_ref?a:e(n)},i.$_do=((e,...t)=>e.apply(n,t)),i.$_val=(()=>s.val),i.$_set=function(e,n){return function(e){let n=s.publicNames,t=n.indexOf(e);if(~t){let r="$"+e;l(e,r),i[r]=i[e],delete i[e],n[t]=r}}(e),i.$_ref[e]=n,n};let o=s.publicNames;for(let e=0;e<o.length;e++){let t=o[e],r=t;if(t in n){do{r="$"+r}while(r in n);l(t,r)}i[r]=i["$_"+t],o[e]=r}function l(e,n){console.warn&&console.warn("JShorthand: The wrapper method '"+e+"()' has been renamed '"+n+"()' due to a name collision")}return a};